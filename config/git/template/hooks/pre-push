#!/bin/bash

# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local sha1> <remote ref> <remote sha1>

remote="$1"
url="$2"

# Get all commit hashes that would be pushed
z40=0000000000000000000000000000000000000000

HOOK_NAME="$(basename "$0")"
REPO=$(git rev-parse --show-toplevel 2>/dev/null)
REPO_HOOK="$REPO/.githooks/$HOOK_NAME"

if [ -x "$REPO_HOOK" ]; then
  "$REPO_HOOK" "$@"
  if [ $? -ne 0 ]; then
    exit 1
  fi
fi

mainline=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's|^refs/remotes/origin/||')
[ -z "$mainline" ] && mainline="main" # Default to main if not set

while read local_ref local_sha remote_ref remote_sha; do
  # Skip if not pushing to mainline branch
  if ! echo "$remote_ref" | grep -q "refs/heads/$mainline"; then
    continue
  fi

  if [ "$local_sha" = $z40 ]; then
    # Handle branch deletion
    continue
  elif [ "$remote_sha" = $z40 ]; then
    # New branch, examine all commits
    range="$local_sha"
  else
    # Update to existing branch, examine new commits
    range="$remote_sha..$local_sha"
  fi

  # Check for WIP commits (case insensitive)
  commit=$(git log --format=%H --grep="^wip$" --grep="^wip " --grep="\[wip\]" -i "$range")
  if [ -n "$commit" ]; then
    echo "Error: found WIP commit in $local_ref, not pushing to $mainline"
    exit 1
  fi

  # Check for fixup commits
  commit=$(git log --format=%H --grep="^fixup!" "$range")
  if [ -n "$commit" ]; then
    echo "Error: found fixup commit in $local_ref, not pushing to $mainline"
    exit 1
  fi
done

exit 0
