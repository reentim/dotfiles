# append
snippet ap "ap" w
append(${1:slice}, ${2:value})
endsnippet

# bool
snippet bl "bl" w
bool
endsnippet

# byte 
snippet bt "bt" w
byte
endsnippet

# break
snippet br "br" w
break
endsnippet

# channel
snippet ch "ch" w
chan ${1:int}
endsnippet

# case
snippet cs "cs" w
case ${1:value}:
	${2:/* code */}
endsnippet

# const
snippet c "c" w
const ${1:NAME} = ${2:0}
endsnippet

# constants with iota
snippet co "co" w
const (
	${1:NAME1} = iota
	${2:NAME2}
)
endsnippet

# continue
snippet cn "cn" w
continue
endsnippet

# defer 
snippet df "df" w
defer ${1:func}()
endsnippet

# defer recover
snippet dfr "dfr" w
defer func() {
	if err := recover(); err != nil {
		${1:/* code */}
	}
}()
endsnippet

# gpl
snippet gpl "gpl" w
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright (C) ${1:Author}, `!v strftime("%Y")`
 */
${2}
endsnippet

# int
snippet i "i" w
int
endsnippet

# import 
snippet im "im" w
import (
	"${1:package}" 
)${2}
endsnippet

# interface 
snippet in "in" w
interface{}
endsnippet

# full interface snippet 
snippet inf "inf" w
interface ${1:name} {
	${2:/* methods */}
}${3}
endsnippet

# if condition
snippet if "if" w
if ${1:/* condition */} {
	${2:/* code */}
}${2}
endsnippet

# else snippet
snippet el "el" w
else {
	${1}
}${2}
endsnippet

# error snippet
snippet ir "ir" w
if err != nil {
	return err
}
${1}
endsnippet

# false
snippet f "f" w
false
endsnippet

# fallthrough
snippet ft "ft" w
fallthrough
endsnippet

# float
snippet fl "fl" w
float32
endsnippet

# float32
snippet f3 "f3" w
float32
endsnippet

# float64
snippet f6 "f6" w
float64
endsnippet

# if else
snippet ie "ie" w
if ${1:/* condition */} {
	${2:/* code */}
} else {
	${3}
}
${4}
endsnippet

# for loop
snippet fo "fo" w
for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {
	${4:/* code */}
}
${5}
endsnippet

# for range loop
snippet fr "fr" w
for ${1:k}, ${2:v} := range ${3} {
	${4:/* code */}
}
${5}
endsnippet

# function simple 
snippet fun "fun" w
func ${1:funcName}(${2}) ${3:error} {
	${4:/* code */}
}
${5}
endsnippet

# function on receiver 
snippet fum "fum" w
func (self ${1:type}) ${2:funcName}(${3}) ${4:error} {
	${5:/* code */}
}
${6}
endsnippet

# log printf
snippet lf "lf" w
log.Printf("%${1:s}", ${2:var})${3}
endsnippet

# log printf
snippet lp "lp" w
log.Println("${1}")${2}
endsnippet

# make
snippet mk "mk" w
make(${1:[]string}, ${2:0})
endsnippet

# map 
snippet mp "mp" w
map[${1:string}]${2:int}
endsnippet

# main()
snippet main "main" w
func main() {
	${1:/* code */}
}
${2}
endsnippet

# new
snippet nw "nw" w
new(${1:type})
endsnippet

# panic 
snippet pn "pn" w
panic("${1:msg}")
endsnippet

# print
snippet pr "pr" w
fmt.Printf("%${1:s}\n", ${2:var})${3}
endsnippet

# range 
snippet rn "rn" w
range ${1}
endsnippet

# return 
snippet rt "rt" w
return ${1}
endsnippet

# result 
snippet rs "rs" w
result
endsnippet

# select
snippet sl "sl" w
select {
case ${1:v1} := <-${2:chan1}
	${3:/* code */}
case ${4:v2} := <-${5:chan2}
	${6:/* code */}
default:
	${7:/* code */}
}
endsnippet

# string
snippet sr "sr" w
string
endsnippet

# struct
snippet st "st" w
struct ${1:name} {
	${2:/* data */}
}
${3}
endsnippet

# switch 
snippet sw "sw" w
switch ${1:var} {
case ${2:value1}:
	${3:/* code */}
case ${4:value2}:
	${5:/* code */}
default:
	${6:/* code */}
}
endsnippet

snippet sp "sp" w
fmt.Sprintf("%${1:s}", ${2:var})${3}
endsnippet

# true 
snippet t "t" w
true
endsnippet

# variable declaration
snippet v "v" w
var ${1:t} ${2:string}
endsnippet


