################################################################
# Â© Copyright 2011 Konstantin Gorodinskiy. All Rights Reserved.#
# Do What The Fuck You Want To Public License, Version 2.      #
# See http://sam.zoy.org/wtfpl/COPYING for more details.       #
################################################################
# Scala lang
#if
snippet if "if" w
if(${1:obj}) {
	${2:/* code */}
}
endsnippet

#if not
snippet ifn "ifn" w
if(!${1:obj}) {
	${2:/* code */}
}
endsnippet

#if-else
snippet ifel "ifel" w
if(${1:obj}) {
	${2:/* code */}
} else {
	${3:/* code */}
}
endsnippet

#if-else-if
snippet ifelif "ifelif" w
if(${1:obj}) {
	${2:/* code */}
} else if(${3:obj}) {
	${4:/* code */}
}
endsnippet

#while loop
snippet while "while" w
while (${1:obj}) {
	${2:/* code */}
}
endsnippet

#for loop(classic)
snippet for "for" w
for (${1:item} <- ${2:obj}) {
	${3:/* code */}
}
endsnippet

#for loop(indexed)
snippet fori "fori" w
for (${1:i} <- ${2:0} to ${3:obj}.length) {
	${4:/* code */}
}
endsnippet

#exceptions
snippet try "try" w
try {
	${1:/* code */}
} catch {
	case e: FileNotFoundException => ${2:/* code */}
	case e: IOException => ${3:/* code */}
} finally {
	${4:/* code */}
}
endsnippet

#match
snippet match "match" w
${1: obj} match {
	case ${2:e} => ${3:/* code */}
	case _ => ${4:/* code */}
}
endsnippet

#case
snippet case "case" w
case ${1:value} => ${2:/* code */}
endsnippet

############################
# methods and arguments
#
#arg
snippet arg "arg" w
${1:a}: ${2:T}${3:, arg}
endsnippet

#args
snippet args "args" w
${1:args}: ${2:T}*
endsnippet

#def
snippet def "def" w
def ${1:name}(${2:arg}) = ${3:}
endsnippet

#private def
snippet prdef "prdef" w
private def ${1:name}(${2:arg}) = ${3:}
endsnippet

#override def
snippet ovdef "ovdef" w
override def ${1:name}(${2:arg}) = ${3:}
endsnippet

#first class function(see scalabook p 188)
snippet fcf "fcf" w
(${1:a}: ${2:T}) => $1 ${3:/* code */}
endsnippet

snippet => "=>" w
${1:name} => ${2:/* code */}
endsnippet

#recursion
snippet rec "rec" w
def ${1:name}(${2:arg}) =
	if($2) $2
	else $1($2)
endsnippet

#curried method
snippet crdef "crdef" w
def ${1:name}(${2:arg})(${3:arg}) = ${4:}
endsnippet

#main method
#check validity of T
snippet main "main" w
def main(args: Array[String]):${1:T} = ${2:}
endsnippet

############################
# basic types(general purpose)
# you might want to use basic types snippets
#1
snippet T "Double" w
dbl
endsnippet

#2
snippet T "Int" w
int
endsnippet

#3
snippet T "Long" w
lng
endsnippet

#4
snippet T "Char" w
chr
endsnippet

#5
snippet T "String" w
str
endsnippet

#6
snippet T "Array" w
arr
endsnippet

#7
snippet T "Buffer" w
buf
endsnippet

#8
snippet T "List" w
list
endsnippet

#9
snippet T "Tuple" w
tpl
endsnippet

#10
snippet T "Set" w
set
endsnippet

#11
snippet T "Map" w
map
endsnippet

#12
snippet T "HashSet" w
hset
endsnippet

#13
snippet T "HashMap" w
hmap
endsnippet

#14
snippet T "Boolean" w
bool
endsnippet

#end
#named snippets for types
snippet bool "bool" w
Boolean
endsnippet

snippet anyr "anyr" w
AnyRef
endsnippet

snippet dbl "dbl" w
Double
endsnippet

snippet int "int" w
Int
endsnippet

snippet str "str" w
String
endsnippet

snippet chr "chr" w
Char
endsnippet

snippet lng "lng" w
Long
endsnippet

snippet arr "arr" w
Array${1:[T]}${2:()}
endsnippet

snippet buf "buf" w
Buffer${1:[T]}${2:()}
endsnippet

snippet list "list" w
List${1:[T]}${2:()}
endsnippet

snippet tpl "tpl" w
Tuple${1:2}[${2:T},${3:T}]
endsnippet

snippet set "set" w
Set${1:[T]}${2:()}
endsnippet

snippet hset "hset" w
HashSet${1:[T]}${2:()}
endsnippet

snippet mhset "mhset" w
mutable.HashSet${1:[T]}${2:()}
endsnippet

#for maps
snippet keyval "keyval" w
${1:key}->${2:val}${3:, keyval}
endsnippet

snippet map "map" w
Map[${1:T},${2:T}]${3:(keyval)}
endsnippet

snippet hmap "hmap" w
HashMap[${1:T},${2:T}]${3:(keyval)}
endsnippet

snippet mmap "mmap" w
mutable.Map[${1:T},${2:T}]${3:(keyval)}
endsnippet

snippet mhmap "mhmap" w
mutable.HashMap[${1:T},${2:T}]${3:(keyval)}
endsnippet

#TODO add TreeMap and TreeSet
#asInstanceOf[]
snippet as "as" w
${1:name}.asInstanceOf[${2:T}]
endsnippet

#isInstanceOf[]
#end
#collections methods
#scope() with one arg
snippet (a "(a" w
(${1:a} => ${2:/* code */})
endsnippet

#scope() with two args
snippet {( "{(" w
{(${1:a},${2:b}) =>
	${3:/* code */}
}
endsnippet

#filter
snippet filter "filter" w
${1:name}.filter (a
endsnippet

#map function
snippet mapf "mapf" w
${1:name}.map (a
endsnippet

#flatmap
snippet flatmap "flatmap" w
${1:name}.flatMap${2:[T]}(a
endsnippet

#fold left
snippet fldl "fldl" w
${1:name}.foldLeft(${2:first}) {(
endsnippet

#fold right
snippet fldr "fldr" w
${1:name}.foldRight(${2:first}) {(
endsnippet

#fold left operator(if u wanna reduce readability of ur code)
#use wildcard symbols
snippet /: "/:" w
(${1:first}/:${2:name})(${3:/* code */})
endsnippet

#fold right operator
snippet :\ ":\" w
(${1:first}:\${2:name})(${3:/* code */})
endsnippet

#reduce left
snippet redl "redl" w
${1:name}.reduceLeft[${2:T}] {(
endsnippet

#reduce right
snippet redr "redr" w
${1:name}.reduceRight[${2:T}] {(
endsnippet

#zipWithIndex(safe way).
#see http://daily-scala.blogspot.com/2010/05/zipwithindex.html
snippet zipwi "zipwi" w
${1:name}.view.zipWithIndex
endsnippet

#split
snippet spl "spl" w
${1:name}.split("${2:,}")
endsnippet

#end
snippet val "val" w
val ${1:name}${2:: T} = ${3:value}
endsnippet

snippet var "var" w
var ${1:name}${2:: T} = ${3:value}
endsnippet

############################
# classes
#
#extends
snippet extends "extends" w
extends ${1:what}
endsnippet

#with
snippet with "with" w
with ${1:what}${2: with}
endsnippet

#auxiliary constructor(a. this)
snippet athis "athis" w
def this(arg) = this(arg)
endsnippet

#abstract class
snippet abstract "abstract" w
abstract class ${1:name}${2:(arg)}${3: extends }${4: with} {
	${5:override def toString = "$1"}
	${6:/* code */}
}
endsnippet

#class
snippet class "class" w
class ${1:name}${2:(arg)}${3: extends }${4: with} {
	${5:override def toString = "$1"}
	${6:/* code */}
}
endsnippet

#object
snippet object "object" w
object ${1:name}${2:(arg)}${3: extends }${4: with} ${5:}
endsnippet

#trait
snippet trait "trait" w
trait ${1:name}${2: extends }${3: with} {
	${4:}
}
endsnippet

#class with trait Ordered(page 265)
snippet ordered "ordered" w
class ${1:name}${2:(arg)} extends Ordered[$1] ${3: with} {
	${4:override def toString = "$1"}
	def compare(that: $1) = ${5:this - that}
	${6:/* code */}
}
endsnippet

#case class
snippet casecl "casecl" w
case class ${1:name}${2:(arg)}${3: extends }${4: with} ${5:}
endsnippet

############################
# testing
#
#scalatest imports
snippet scalatest "scalatest" w
${1:import org.scalatest.Suite}
${2:import org.scalatest.FunSuite}
endsnippet

#assert
snippet assert "assert" w
assert(${1:a}==${2:b})
endsnippet

#ensuring(p 296)
snippet ensuring "ensuring" w
ifel ensuring(${1:a}==${2:b})
endsnippet

#expect
snippet expect "expect" w
expect(${1:what}) {
endsnippet

#intercept
snippet intercept "intercept" w
intercept[${1:IllegalArgumentException}] {
endsnippet

#test
snippet test "test" w
test("${1:description}") {
endsnippet

#suite
snippet suite "suite" w
class ${1:name} extends Suite {
	def test() {
}
endsnippet

#funsuite
snippet fsuite "fsuite" w
class ${1:name} extends FunSuite {
	test("${2:description}") {
}
endsnippet

############################
# SBT
#
snippet webproject "webproject" w
import sbt._
class ${1:Name}(info: ProjectInfo) extends DefaultWebProject(info) {
	val liftVersion = "${2:2.3}"
	override def libraryDependencies = Set(
	) ++ super.libraryDependencies
	val snapshots = ScalaToolsSnapshots
}
endsnippet

#depencies
snippet liftjar "liftjar" w
"net.liftweb" %% "${1:lib}" % liftVersion % "compile->default",
endsnippet

snippet jettyjar "jettyjar" w
"org.mortbay.jetty" % "jetty" % "${1:version}" % "test->default",
endsnippet

############################
# Lift
#
#lift imports
snippet liftimports "liftimports" w
import _root_.net.liftweb.http._
import S._
import _root_.net.liftweb.util._
import Helpers._
import _root_.scala.xml._
endsnippet

#TODO LIFT,SBT,WEB.XML,HTML snippets

