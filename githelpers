#!/usr/bin/env bash

set -e

wip() {
  git add -A
  git commit --no-verify -m 'wip'
}

unwip() {
  if [ "`git log --format=%B -n 1 HEAD`" = "wip" ]; then
    git reset --soft HEAD~1;
    git reset HEAD;
  fi;
}

diff_branch() {
  if [[ $1 == *"--"* ]]; then
    branch=$(git rev-parse --abbrev-ref HEAD)
    options=$*
  else
    branch=$1
    options=${@:2}
  fi
  git diff $options $(git merge-base --fork-point origin/$FORK_POINT $branch)..$branch
}

log_patch() {
  options=$*
  git --no-pager log $options --patch --decorate --color | less --pattern '^commit'
}

log_patch_reverse_branch() {
  options=$*
  start=$(git merge-base --fork-point origin/$FORK_POINT)
  git --no-pager log $start..HEAD --patch --reverse --color $options | less --pattern '^commit'
}

merge_branch_origin_to_master() {
  branch=$(git rev-parse --abbrev-ref HEAD)
  git checkout master
  git merge --no-ff origin/$branch
}

selecta_branch() {
  git branch -a |
    cut -c 3- |
    sed 's:remotes/origin/::' |
    grep -v HEAD |
    sort -u |
    selecta |
    xargs git checkout
}

selecta_recent_branch() {
bash << EOS
  cat <(git reflog -n 100 | grep -E 'checkout:|Branch: renamed' | grep -Eo "\S+$") \
      <(git branch | cut -c 3-) \
      | sed 's:refs/heads/::' \
      | awk '!x[\$0]++' \
      | grep -v $(git rev-parse --abbrev-ref HEAD) \
      | selecta \
      | xargs git checkout
EOS
}

tail_origin_log() {
  log_options=$1
  branch='origin/master'
  interval=360

  while true; do
    clear

    git --no-pager log --color --graph --decorate $log_options $branch -20 \
      | head -n $(expr $(tput lines) - 1)

    sleep $interval

    git fetch
  done
}

pretty_log() {
  git log --graph --pretty=format:"%C(yellow)%h%C(green) %ar%C(blue) %an%C(red)%d%C(reset) %s"
}

pretty_shortdate_log() {
  git --no-pager log --graph --color --pretty=format:"%C(yellow)%h %C(green)|%ar|%C(red)%d%C(reset) %s" \
    | sed -E "s/\|([0-9]+) ([a-z]).*\|/\1\2/" \
    | less
}
