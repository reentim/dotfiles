##
## Load with `autoload -U zgitinit; zgitinit'
##

typeset -gA zgit_info
zgit_info=()

zgit_chpwd_hook() {
  zgit_info_update
}

zgit_preexec_hook() {
  if [[ $2 == git\ * ]] || [[ $2 == *\ git\ * ]] || [[ $2 == jj\ * ]] || [[ $2 == *\ jj\ * ]]; then
    zgit_precmd_do_update=1
  fi
}

zgit_precmd_hook() {
  if [ $zgit_precmd_do_update ]; then
    unset zgit_precmd_do_update
    zgit_info_update
  fi
}

zgit_find_jj_gitdir() {
  # Find the jj repository's git backend
  local jj_dir=$(jj --color=never git path 2>/dev/null)
  if [ $? -eq 0 ] && [ -n "$jj_dir" ]; then
    echo "$jj_dir"
    return 0
  fi

  # Fallback method: look for .jj/repo/store/git
  local current_dir="$PWD"
  while [ "$current_dir" != "/" ]; do
    if [ -d "$current_dir/.jj/repo/store/git" ]; then
      echo "$current_dir/.jj/repo/store/git"
      return 0
    fi
    current_dir=$(dirname "$current_dir")
  done
  return 1
}

zgit_info_update() {
  zgit_info=()

  # Try standard git first
  local gitdir="$(git rev-parse --git-dir 2>/dev/null)"
  local git_exit_code=$?

  # If standard git fails, try jj
  if [ $git_exit_code -ne 0 ] || [ -z "$gitdir" ]; then
    gitdir=$(zgit_find_jj_gitdir)
    if [ $? -ne 0 ] || [ -z "$gitdir" ]; then
      return
    fi
    zgit_info[is_jj]=true
  else
    zgit_info[is_jj]=false
  fi

  zgit_info[dir]=$gitdir

  # Use git -C for jj repositories to properly reference the git backend
  if [ "$zgit_info[is_jj]" = "true" ]; then
    zgit_info[bare]=$(git -C "$gitdir" rev-parse --is-bare-repository)
    zgit_info[inwork]=true  # jj is always inside a work tree
  else
    zgit_info[bare]=$(git rev-parse --is-bare-repository)
    zgit_info[inwork]=$(git rev-parse --is-inside-work-tree)
  fi
}

zgit_isgit() {
  if [ -z "$zgit_info[dir]" ]; then
    return 1
  else
    return 0
  fi
}

zgit_inworktree() {
  zgit_isgit || return
  if [ "$zgit_info[inwork]" = "true" ]; then
    return 0
  else
    return 1
  fi
}

zgit_isbare() {
  zgit_isgit || return
  if [ "$zgit_info[bare]" = "true" ]; then
    return 0
  else
    return 1
  fi
}

zgit_head() {
  zgit_isgit || return 1

  if [ -z "$zgit_info[head]" ]; then
    local name=''

    if [ "$zgit_info[is_jj]" = "true" ]; then
      # For jj, try to get current revision
      name=$(jj --color=never status --verbose | grep 'Working copy: ' | sed 's/Working copy: //' | awk '{print $1}' 2>/dev/null)
      if [ -z "$name" ]; then
        # Fallback to git with explicit path
        name=$(git -C "$zgit_info[dir]" symbolic-ref -q HEAD)
      fi
    else
      name=$(git symbolic-ref -q HEAD)
    fi

    if [ $? -eq 0 ]; then
      if [[ $name == refs/(heads|tags)/* ]]; then
        name=${name#refs/(heads|tags)/}
      fi
    else
      if [ "$zgit_info[is_jj]" = "true" ]; then
        name=$(git -C "$zgit_info[dir]" rev-parse --short HEAD)
      else
        name=$(git rev-parse --short HEAD)
      fi

      if [ $? -ne 0 ]; then
        return 1
      elif [[ $name == remotes/* ]]; then
        name=${name#remotes/}
      fi
    fi
    zgit_info[head]=$name
  fi

  echo $zgit_info[head]
}

zgit_branch() {
  zgit_isgit || return 1
  zgit_isbare && return 1

  if [ -z "$zgit_info[branch]" ]; then
    local branch

    if [ "$zgit_info[is_jj]" = "true" ]; then
      # For jj, try to get current branch
      branch=$(jj --color=never branch list | grep '(current)' | awk '{print $1}' 2>/dev/null)
      if [ -z "$branch" ]; then
        # Fallback to git with explicit path
        branch=$(git -C "$zgit_info[dir]" symbolic-ref HEAD 2>/dev/null)
      fi
    else
      branch=$(git symbolic-ref HEAD 2>/dev/null)
    fi

    if [ $? -eq 0 ]; then
      branch=${branch##*/}
    else
      if [ "$zgit_info[is_jj]" = "true" ]; then
        branch=$(git -C "$zgit_info[dir]" name-rev --name-only --always HEAD)
      else
        branch=$(git name-rev --name-only --always HEAD)
      fi
    fi
    zgit_info[branch]=$branch
  fi

  echo $zgit_info[branch]
  return 0
}

zgit_tracking_remote() {
  zgit_isgit || return 1
  zgit_isbare && return 1

  local branch
  if [ -n "$1" ]; then
    branch=$1
  elif [ -z "$zgit_info[branch]" ]; then
    branch=$(zgit_branch)
    [ $? -ne 0 ] && return 1
  else
    branch=$zgit_info[branch]
  fi

  local k="tracking_$branch"
  local remote
  if [ -z "$zgit_info[$k]" ]; then
    if [ "$zgit_info[is_jj]" = "true" ]; then
      remote=$(git -C "$zgit_info[dir]" config branch.$branch.remote)
    else
      remote=$(git config branch.$branch.remote)
    fi
    zgit_info[$k]=$remote
  fi

  echo $zgit_info[$k]
  return 0
}

zgit_tracking_merge() {
  zgit_isgit || return 1
  zgit_isbare && return 1

  local branch
  if [ -z "$zgit_info[branch]" ]; then
    branch=$(zgit_branch)
    [ $? -ne 0 ] && return 1
  else
    branch=$zgit_info[branch]
  fi

  local remote=$(zgit_tracking_remote $branch)
  [ $? -ne 0 ] && return 1
  if [ -n "$remote" ]; then # tracking branch
    local merge
    if [ "$zgit_info[is_jj]" = "true" ]; then
      merge=$(git -C "$zgit_info[dir]" config branch.$branch.merge)
    else
      merge=$(git config branch.$branch.merge)
    fi

    if [ $remote != "." ]; then
      merge=$remote/$(basename $merge)
    fi
    echo $merge
    return 0
  else
    return 1
  fi
}

zgit_isindexclean() {
  zgit_isgit || return 1

  if [ "$zgit_info[is_jj]" = "true" ]; then
    # For jj, check if there are any staged changes
    if git -C "$zgit_info[dir]" diff --quiet --cached 2>/dev/null; then
      return 0
    else
      return 1
    fi
  else
    if git diff --quiet --cached 2>/dev/null; then
      return 0
    else
      return 1
    fi
  fi
}

zgit_isworktreeclean() {
  zgit_isgit || return 1

  if [ "$zgit_info[is_jj]" = "true" ]; then
    # Check if jj has any unstaged changes
    local jj_status=$(jj --color=never status 2>/dev/null)
    if echo "$jj_status" | grep -q "No changes"; then
      return 0
    else
      # Fallback to git with explicit path
      if git -C "$zgit_info[dir]" diff --quiet 2>/dev/null; then
        return 0
      else
        return 1
      fi
    fi
  else
    if git diff --quiet 2>/dev/null; then
      return 0
    else
      return 1
    fi
  fi
}

zgit_hasuntracked() {
  zgit_isgit || return 1
  local -a flist

  if [ "$zgit_info[is_jj]" = "true" ]; then
    flist=($(git -C "$zgit_info[dir]" ls-files --others --exclude-standard))
  else
    flist=($(git ls-files --others --exclude-standard))
  fi

  if [ $#flist -gt 0 ]; then
    return 0
  else
    return 1
  fi
}

zgit_hasunmerged() {
  zgit_isgit || return 1
  local -a flist

  if [ "$zgit_info[is_jj]" = "true" ]; then
    flist=($(git -C "$zgit_info[dir]" ls-files -u))
  else
    flist=($(git ls-files -u))
  fi

  if [ $#flist -gt 0 ]; then
    return 0
  else
    return 1
  fi
}

zgit_svnhead() {
  zgit_isgit || return 1

  local commit=$1
  if [ -z "$commit" ]; then
    commit='HEAD'
  fi

  if [ "$zgit_info[is_jj]" = "true" ]; then
    git -C "$zgit_info[dir]" show --raw $commit | \
      grep git-svn-id | \
      sed -re 's/^\s*git-svn-id: .*@([0-9]+).*$/\1/'
  else
    git show --raw $commit | \
      grep git-svn-id | \
      sed -re 's/^\s*git-svn-id: .*@([0-9]+).*$/\1/'
  fi
}

zgit_rebaseinfo() {
  zgit_isgit || return 1

  local dotest
  if [ "$zgit_info[is_jj]" = "true" ]; then
    if [ -d $zgit_info[dir]/rebase-merge ]; then
      dotest=$zgit_info[dir]/rebase-merge
    elif [ -d $zgit_info[dir]/.dotest-merge ]; then
      dotest=$zgit_info[dir]/.dotest-merge
    elif [ -d .dotest ]; then
      dotest=.dotest
    else
      return 1
    fi
  else
    if [ -d $zgit_info[dir]/rebase-merge ]; then
      dotest=$zgit_info[dir]/rebase-merge
    elif [ -d $zgit_info[dir]/.dotest-merge ]; then
      dotest=$zgit_info[dir]/.dotest-merge
    elif [ -d .dotest ]; then
      dotest=.dotest
    else
      return 1
    fi
  fi

  zgit_info[dotest]=$dotest

  zgit_info[rb_onto]=$(cat "$dotest/onto")
  zgit_info[rb_upstream]=$(cat "$dotest/upstream")
  if [ -f "$dotest/orig-head" ]; then
    zgit_info[rb_head]=$(cat "$dotest/orig-head")
  elif [ -f "$dotest/head" ]; then
    zgit_info[rb_head]=$(cat "$dotest/head")
  fi
  zgit_info[rb_head_name]=$(cat "$dotest/head-name")

  return 0
}

zgitinit() {
  typeset -ga chpwd_functions
  typeset -ga preexec_functions
  typeset -ga precmd_functions
  chpwd_functions+='zgit_chpwd_hook'
  preexec_functions+='zgit_preexec_hook'
  precmd_functions+='zgit_precmd_hook'
}

zgitinit
zgit_info_update

# vim:set ft=zsh:
